# Target Sponsors and Integration Plan

## Flow

We will deploy the **Asset Registry and Lifecycle smart contracts** directly on **Flow‚Äôs EVM environment**. This lets us take advantage of Flow‚Äôs growing ecosystem for consumer-facing applications while keeping Solidity compatibility. By using Flow, we demonstrate how serious, real-world asset tracking can live on a scalable chain optimized for usability. This positions our project to compete for Flow‚Äôs prize pool, since we are making Flow the home chain for our app.

---

## Walrus

For every document upload (e.g., purchase invoices, inspection photos, maintenance receipts), we will **store the files in Walrus decentralized storage**. The smart contracts only store the file hash and URI, while the actual document lives in Walrus. This ensures that sensitive files aren‚Äôt bloated on-chain but remain verifiable at any time. By using Walrus, we showcase a key integration point: trusted off-chain data with on-chain proofs. This aligns neatly with Walrus‚Äô goals of decentralized file persistence.

---

## Privy / Dynamic

End users will connect to the Asset Passport via **Privy or Dynamic‚Äôs embedded wallet experience**. Our focus is to ensure **no blockchain knowledge is required** to onboard ‚Äî users simply log in, and a wallet is provisioned for them behind the scenes. This wallet becomes their key to creating, owning, and updating assets in the registry. By leveraging Privy/Dynamic, we create a frictionless UX for both web2-native and crypto-native participants, making the project prize-eligible for sponsors focused on wallet onboarding and identity.

---

## ENS

We will add an **ENS handle mapping feature** to improve discoverability of assets. Each asset can be linked to a human-readable ENS name (e.g., `forklift-23.myco.eth`), which is then stored in a helper contract and displayed in the UI. This means a user or company can show their assets with recognizable names rather than cryptic IDs, making the asset passport more accessible to non-technical audiences. This integration ties directly to ENS‚Äôs prize pool by demonstrating new use cases for asset discoverability.

---

## The Graph

All of the events emitted by our contracts ‚Äî asset creation, lifecycle updates, depreciation anchors, and evidence links ‚Äî will be **indexed by The Graph**. This allows us to build the **dashboard, activity feed, and public asset passport views** in a performant and queryable way. Instead of fetching data directly from contracts, The Graph provides us with a structured dataset that can power charts, timelines, and search. This is critical for our demo, since it makes the UI smooth and highlights how decentralized indexing can support real-world asset management.

---

üëâ This way, the story for judges is: **Flow is our home chain, Walrus is our file vault, Privy/Dynamic is our seamless login, ENS makes assets human-readable, and The Graph powers the dashboard.**

___ Technical Implementation Plan ___

Perfect‚Äîhere‚Äôs a **deterministic contract suite** proposal for Asset Passport, with **clear, descriptive function behavior** (no code), and explicit notes on how each piece interacts with **ENS, Flow (EVM), Walrus, Privy/Dynamic, and The Graph**. This is written so you can hand it to Cursor or your team and everyone will know what to build.

---

# Contract Suite (Flow EVM)

> We‚Äôll deploy Solidity contracts to **Flow EVM** to keep everything EVM-compatible (easier with ENS conventions, Privy/Dynamic wallets, and The Graph indexing). No money movement is included anywhere.

**Core set (ship these):**

1. `AssetRegistry`
2. `LifecycleEvents`
3. `DepreciationAnchors`
4. `EvidenceLibrary` (embedded struct + helpers, referenced by the others)

**Optional, nice-to-have (only if time allows):**
5\) `PublicViewLens` (read-only aggregator)
6\) `ENSHandleBook` (UX-level ENS handle binding; no on-chain ENS writes required)

---

## 1) `AssetRegistry` ‚Äî canonical identity & status

**Purpose**
Holds one authoritative record per asset (identity fields, owner, status). Nothing here mutates historically significant data; changes are expressed as events and current-effective fields.

**Key concepts**

* **AssetId (`bytes32`)**: supplied by the caller (deterministic fingerprint, e.g., keccak(name+vendorInvoiceId+serial)), or generated by contract if none provided.
* **Owner (`address`)**: the wallet that controls updates (created via Privy/Dynamic onboarding).
* **Status**: `Draft` ‚Üí `InService` ‚Üí `Retired` or `Disposed`.

**Core functions (described)**

* `createAsset(record)`
  **What it does:** Creates a new asset with initial fields: `name, category, purchaseDate, purchaseCost, country, state, city, serial (optional), description (optional)`, plus zero or more document references (Walrus URIs + content hashes).
  **Side effects:**

  * Assigns `owner = msg.sender`.
  * Sets status to `Draft`.
  * Emits `AssetCreated(assetId, owner, minimalSnapshot)`.
    **Walrus:** Accepts an array of `Evidence` (URI + contentHash).
    **The Graph:** `AssetCreated` is your index anchor.

* `updateCoreFacts(assetId, partialRecord)`
  **What it does:** Adds **non-historical clarifications** (e.g., fix a typo in description, add missing serial). Does **not** change purchase facts or status.
  **Side effects:** Emits `AssetFactsUpdated(assetId, fieldsChanged)` for indexing.

* `setStatus(assetId, newStatus)`
  **What it does:** Changes overall status only when preconditions are met (e.g., cannot dispose before in-service). Typically called **indirectly** by `LifecycleEvents` actions, but remains available to owner as an escape hatch.
  **Side effects:** Emits `AssetStatusChanged(assetId, oldStatus, newStatus)`.

* `attachEvidence(assetId, evidence[])`
  **What it does:** Adds/anchors new **Walrus documents** to the asset record outside of lifecycle event context (e.g., extra photos).
  **Side effects:** Emits `AssetEvidenceAdded(assetId, evidenceHashes[])`.

* `registerBulkAssets(batch[])`
  **What it does:** Creates multiple assets in a single call for CSV imports.
  **Side effects:** Emits `AssetCreated` per item.

**Read helpers**

* `getAsset(assetId)` ‚Üí latest effective core fields.
* `getOwner(assetId)` ‚Üí controlling address.
* `getStatus(assetId)` ‚Üí current status.

**ENS (UX only)**
This contract stores **no ENS state**. If `ENSHandleBook` is used, we store only the **preferred ENS string** in that contract and mirror a pointer (string) here as optional metadata, if desired.

---

## 2) `LifecycleEvents` ‚Äî append-only timeline of typed events

**Purpose**
Keeps the **timeline** of meaningful changes: in-service, maintenance, upgrade, relocation, damage, disposal, correction. Each entry can anchor **Walrus evidence**.

**Event types**

* `InService`
* `Maintenance`
* `Upgrade`
* `Relocation`
* `Damage`
* `Disposed`
* `Correction` (non-destructive amendment, e.g., ‚Äúserial updated‚Äù)

**Core functions (described)**

* `markInService(assetId, inServiceDate, evidence[])`
  **What it does:** Appends an `InService` event and (optionally) evidence (photo, inspection report); flips status in `AssetRegistry` to `InService`.
  **Side effects:**

  * Emits `EventLogged(assetId, InService, payloadHash)`.
  * Calls `AssetRegistry.setStatus(..., InService)`.

* `logMaintenance(assetId, date, costOptional, notes, evidence[])`
  **What it does:** Adds a maintenance entry with optional cost and docs (invoice, photos).
  **Side effects:** Emits `EventLogged(assetId, Maintenance, payloadHash)`.

* `logUpgrade(assetId, date, capitalCostOptional, notes, evidence[])`
  **What it does:** Records an upgrade that **may** prompt a depreciation change later.
  **Side effects:** Emits `EventLogged(assetId, Upgrade, payloadHash)`.

* `logRelocation(assetId, date, newCountry, newState, newCity, notes, evidence[])`
  **What it does:** Records a move; optionally updates `AssetRegistry` location view to keep lists/search sane.
  **Side effects:** Emits `EventLogged(assetId, Relocation, payloadHash)`.

* `logDamage(assetId, date, severity, notes, evidence[])`
  **What it does:** Records damage with supporting media.
  **Side effects:** Emits `EventLogged(assetId, Damage, payloadHash)`.

* `dispose(assetId, date, dispositionType, notes, evidence[])`
  **What it does:** Appends disposal info (**no proceeds handling**) and marks asset `Disposed`.
  **Side effects:**

  * Emits `EventLogged(assetId, Disposed, payloadHash)`.
  * Calls `AssetRegistry.setStatus(..., Disposed)`.

* `logCorrection(assetId, date, correctedField, oldValueHash, newValueHash, evidence[])`
  **What it does:** Non-destructive fix with a clear forensic trail.
  **Side effects:** Emits `EventLogged(assetId, Correction, payloadHash)`.

**Guards & sequencing**

* You cannot `dispose` before `InService`.
* `Relocation`/`Maintenance`/`Upgrade` must target `InService` assets.

**Walrus**
Every `log*` function accepts `Evidence[]` (URI + contentHash). The chain stores only hashes/URIs; content lives in Walrus.

**The Graph**

* Single, uniform `EventLogged` with an `eventType enum` and a `payloadHash` (+ basic typed fields in the log) makes indexing trivial and robust.

---

## 3) `DepreciationAnchors` ‚Äî verifiable inputs; math off-chain

**Purpose**
Anchors **parameters and changes** so anyone can recompute NBV for any date (including your **timeline simulation**). MVP assumes **straight-line** only.

**Core functions (described)**

* `setInitialParams(assetId, method = StraightLine, usefulLifeYears, salvageValueOptional, effectiveStartDate)`
  **What it does:** Stores initial parameters (usually called during or right after `markInService`).
  **Side effects:** Emits `DepParamsSet(assetId, method, lifeYears, salvageOrZero, startDate)`.

* `amendParams(assetId, reason, newUsefulLifeYearsOptional, newSalvageOptional, newEffectiveStartOptional)`
  **What it does:** Appends a **parameter change** (e.g., after `logUpgrade`).
  **Side effects:** Emits `DepParamsChanged(assetId, reason, changedFieldsMask)`.

* `getEffectiveParams(assetId)`
  **What it returns:** The **current effective** set (after applying all changes), so any client/subgraph can compute monthly depreciation and NBV at a chosen view date.

**Assumptions (MVP)**

* Method = **Straight-line** (fixed annual amount).
* NBV(t) = max(0, cost ‚Äì accumulatedDepreciation(t)); salvage optional.

**The Graph**
Index `DepParamsSet` and `DepParamsChanged` to drive charts and the simulated time slider.

---

## 4) `EvidenceLibrary` ‚Äî shared struct & helpers (embedded)

**Purpose**
Standardizes how **evidence** is attached everywhere.

**Struct shape (conceptual, not code)**

* `contentHash` (bytes32) ‚Äî hash of the exact file.
* `uri` (string) ‚Äî Walrus (or IPFS) URI.
* `mediaType` (string) ‚Äî e.g., `application/pdf`, `image/jpeg`.
* `note` (string, optional)\`
* `uploadedAt` (uint64, epoch seconds) ‚Äî client-provided.

**Used by**
`AssetRegistry` and `LifecycleEvents` so your ‚ÄúVerify evidence‚Äù button can always re-hash the file and compare to `contentHash`.

---

## 5) `PublicViewLens` (optional) ‚Äî read-only aggregator

**Purpose**
Makes the **public passport URL** fast by returning a bundle in one call.

**Core read functions (described)**

* `getAssetSnapshot(assetId)`
  **What it returns:** Current effective core facts from `AssetRegistry` + last known status.

* `getTimeline(assetId, page, pageSize)`
  **What it returns:** A paginated list of typed events from `LifecycleEvents` with their `payloadHash` and evidence pointers.

* `getDepreciationInputs(assetId)`
  **What it returns:** The latest effective parameters from `DepreciationAnchors` so the UI can compute NBV instantly for the selected timeline date.

**The Graph**
You can implement the public page **either** by on-chain Lens reads **or** a subgraph query; Lens is optional if The Graph is sufficient.

---

## 6) `ENSHandleBook` (optional) ‚Äî UX-level ENS handle binding

**Purpose**
Stores the **human-readable ENS handle** the owner wants to associate with an asset (e.g., `forklift-23.myco.eth`). We **do not** attempt to write to ENS on-chain here (Flow EVM won‚Äôt host the ENS registry). This is a UX-only link that improves display and search.

**Core functions (described)**

* `setEnsHandle(assetId, handleString)`
  **What it does:** Records a preferred ENS name (string).
  **Side effects:** Emits `EnsHandleSet(assetId, handle)`; UI shows it immediately.

* `clearEnsHandle(assetId)`
  **What it does:** Removes the preferred handle if it‚Äôs wrong/outdated.
  **Side effects:** Emits `EnsHandleCleared(assetId)`.

**Future-proofing**
If later you control an ENS subdomain, you can add an off-chain worker to actually mint subnames and then **mirror** the minted name here.

---

# How each integration plugs in

* **Flow (EVM):** All contracts above are deployed to **Flow EVM** so your app is ‚Äúon Flow,‚Äù while staying Solidity-friendly for rapid hackathon iteration.

* **Walrus:** Every place that accepts `Evidence[]` expects **URI + contentHash** only. Files live in Walrus; the smart contracts never store blobs‚Äîjust hashes/URIs. Your public page re-hashes to verify.

* **Privy / Dynamic:** Users authenticate and get a wallet seamlessly. On-chain, that just means `msg.sender` is a normal EVM address‚Äîthe contracts enforce `owner` permissions and (optionally) a single `operator` per asset if you need it.

* **The Graph:**

  * Index **these emitted events**: `AssetCreated`, `AssetFactsUpdated`, `AssetStatusChanged`, `AssetEvidenceAdded`, `EventLogged(‚Ä¶ typed)`, `DepParamsSet`, `DepParamsChanged`, `EnsHandleSet/Cleared`.
  * Your **Dashboard** charts and **timeline simulation** read from the subgraph: to simulate time you just select a view date and recompute NBV from the anchored parameters.

* **ENS (UX):** Start with `ENSHandleBook` to display the chosen ENS string; do not attempt on-chain ENS writes during the hackathon. It‚Äôs enough to show human-readable labels in your lists and public passport.

---

# Minimal permissioning (keep it simple)

* `owner` (the wallet that created the asset via Privy/Dynamic) can call all state-changing functions for that asset.
* Optional: one `operator` per asset (set in `AssetRegistry`) allowed to log routine events (maintenance/relocation), but **not** disposal or depreciation parameter changes.

---

# Deterministic event names (so The Graph is easy)

* `AssetCreated(assetId, owner, snapshotHash)`
* `AssetFactsUpdated(assetId, fieldsMask)`
* `AssetStatusChanged(assetId, oldStatus, newStatus)`
* `AssetEvidenceAdded(assetId, evidenceHashes[])`
* `EventLogged(assetId, eventType, payloadHash)`
* `DepParamsSet(assetId, method, lifeYears, salvage, startDate)`
* `DepParamsChanged(assetId, reasonCode, changedFieldsMask)`
* `EnsHandleSet(assetId, handle)` / `EnsHandleCleared(assetId)`

*(Keep payload details minimal but structured; the heavy data is in Walrus, referenced by hashes.)*

---

## Recommended build order (so you can demo fast)

1. `AssetRegistry` + `LifecycleEvents` (InService, Maintenance, Disposal).
2. `DepreciationAnchors` (Straight-line params; UI computes NBV).
3. Hook up **Walrus** evidence to creation + one event.
4. Add The Graph subgraph for index & charts.
5. (Optional) `PublicViewLens` for a snappy public URL.
6. (Optional) `ENSHandleBook` for human-readable names in UI.

This set gives you a crisp, prize-aligned MVP with **clear ownership, verifiable documents, a rich timeline, and a silky demo**‚Äîwhile keeping the chain side clean and realistic.
